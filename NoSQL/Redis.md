[TOC]

## Redis简介	

​	Redis是一种key-value型数据库，它是基于内存操作的，所以性能非常快，支持5种基本数据类型：string、list、set、hash、zset，还包括了bitmap、布隆过滤器等高级数据结构。我们常用它来做数据缓存，能有效减少数据库的访问压力，当然还有很多应用场景，比如分布式锁、发布订阅、实时排行榜等，它还支持结合lua语言保证原子性操作，但由于它是基于内存的，所以可能会出现服务器关闭后数据丢失的情况，所以提供了RDB和AOF这2种持久化机制。



## 淘汰策略

### 四大类淘汰策略

#### LRU (最近最少使用：Least Recently Used)

#### TTL (生存时间：Time To Live)

#### LFU（最不经常使用：Least Frequently Used）

#### No-Eviction(不驱逐)



### 6种淘汰策略

#### volatile-lru

​	针对所有设置了过期时间`expire`的数据集，淘汰最近最少使用的数据。

#### volatile-ttl

​	针对所有设置了过期时间`expire`的数据集，淘汰即将失效的数据。

#### volatile-radom

​	针对所有设置了过期时间`expire`的数据集，随机淘汰一部分数据。

#### allkeys-lru

​	针对**所有**数据集，淘汰最近最少使用的数据。

#### allkeys-radom

​	针对**所有**数据集，随机淘汰一部分数据。

#### no-eviction

​	不执行淘汰策略，不驱逐数据。



### 4.0版本新增2种策略

#### volatile-lfu

​		针对所有设置了过期时间`expire`的数据集，淘汰使用频率最低的数据。

#### allkeys-lfu

​		针对所有设置的数据集，淘汰使用频率最低的数据。



## 持久化机制

​	RDB的优先级比AOF低，当开启了AOF时会优先恢复AOF数据。

### RDB(Redis DataBase)

​	Redis快照，在满足触发条件之后进行原数据的二进制持久化。默认存储文件为`dump.rdb`

##### 持久化同步方式

1. SAVE：阻塞式，必须在数据同步完成之后Redis的其他命令才能执行
2. BGSAVE：forks一个**子进程**执行持久化，子进程运行时不会影响Redis命令的执行，但**子进程创建时会阻塞**，且子进程会消耗内存

##### 优点

1. 灾难恢复速度快
2. 采用二进制存储原数据，文件体积小

##### 缺点

1. 数据丢失，因为持久化策略是满足条件才触发，若本次条件未满足时宕机，则上次持久化之后到宕机这段时间的数据都会丢失掉。



### AOF(Append Only File)

​	对**写操作**的**命令**进行缓存。默认存储文件为`appendonly.aof`。

##### 配置AOF

	开启AOF: appendonly yes
 - 写入策略，`appenfsync`
  - `always`：每一个写操作都会保存到aof文件，涉及IO操作，较慢
  - `everysec`：每间隔一秒把**Redis写操作**写入到aof文件，可能会丢失一秒的数据
  - `no`：Redis不负责写入，由操作系统决定，性能快，但不安全（*不推荐*）

##### 优点

​	1. 实时缓存，可以实现每次写操作都能缓存，最多丢失一秒的数据

##### 缺点

1. 文件体积大，因为保存了所有写命令，文件体积较大，虽然提供了重写`rewrite`压缩体积，但仍然比较大
2. 数据恢复慢



#### 混合模式（TODO）



## Redis问题

### 缓存穿透

​	请求大量不存在的key，比如黑客恶意请求id为负数的key，导致所有请求都打到数据库，造成数据库被压垮。

​	解决方案：

1. **缓存空值**，对请求的key也进行缓存，但设置的失效时间较短，一般为半分钟以内，按业务需求进行设置。

   **注**：有可能key不是非法值，只是未插入到数据库，所以可以设置有insert之后更新缓存（建议先删除再新建缓存）。

2. **布隆过滤器**，将所有查询条件放入过滤器，所有请求先经过过滤器，如果请求值存在则放行，否则直接丢弃。**注：**但可能出现误判情况。



### 缓存雪崩

​	缓存中的key在同一时间大面积失效，导致所有key失效的请求都打到数据库上，造成数据库被压垮。

​	解决方案：

1. **失效时间加随机值**，给key失效时间加一个随机值，防止同一时间失效。、
2. **设置二级缓存**，A1为原始缓存，A2为拷贝缓存，A1的失效时间比A2短，A1失效后访问A2。(*浪费内存*)
3. **加锁**，对失效的key请求进行加锁或者队列请求数据库，加锁考虑使用**双重检查锁**。（*不推荐*）



### 缓存击穿

​	某个热点key突然失效，导致请求都打到数据库。

​	解决方案：

1. **设置热点数据永不失效**
2. **互斥锁**，如果key不存在则用其他key进行setnx加锁，去数据库查并加入缓存，再进行解锁，其他线程/服务/进程发现加锁则等待。

```java
final String KEY_MUTEX = "xxx";
final int EXPIRE_SECS = 6000;
public String get(key) {
    String value = redis.get(key);
    if (value == null) { //代表缓存值过期
        //假设设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(KEY_MUTEX, 1, 3 * 60) == 1) {  //1代表设置成功，其他线程进不来
            //只有第一个线程进行查数据库操作            
            value = db.get(key);
            //也可以使用lua保证以下命令的原子操作
            redis.set(key, value, EXPIRE_SECS);
            redis.del(KEY_MUTEX);//删除互斥锁
         } else {  
            //这个时候可能同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
            sleep(50);
            get(key);  //递归重试，代替while(true)
        }
    }
    return value;
 }
```



## Redis分布式锁

### 为什么要分布式锁？

​	在Java中常用的锁实现方式有synchronized和Lock等，但这些都是JVM级别的，在集群、微服务、分布式被广泛应用的今天，JVM层面的锁机制已不能满足业务需求，所以我们需要引入分布式锁。



### 分布式锁实现方式

#### 数据库唯一索引（MySQL）

​	简单实现：创建一个用于实现的数据表，如lock，表中仅有一个字段如id：

```mysql
CREATE TABLE `lock`(
	id int(20) NOT NULL AUTO_INCREMENT,
	primary key(id)
);
```

​	因为主键索引的值不能重复，在业务层代码只对该表做新增和删除操作，并且新增的数据都是一样的，当有线程使用到锁时会向该表插入一条数据`INSERT INTO lock values(1)`，此时若有其他线程请求锁时会插入一条数据，发现主键冲突会抛出异常，此时该线程只能等待持有线程释放锁（删除记录：`DELETE FROM lock WHERE id = 1`）。

**缺点：**操作数据库性能差，当线程多时数据库访问压力过大。



#### Reids分布式锁

​	SETNX：**SET** if **N**ot e**X**ists，当Redis不存在该key时加入缓存成功，若已存在该key则会返回null，能很好地实现上述MySQL分布式锁的效果，且能有效弥补MySQL的缺点。

​	**设计：**当有线程请求使用锁时向Redis插入锁信息：```setnx key value expire 30000```，

| 关键字 | 描述                                                         |
| :----: | :----------------------------------------------------------- |
|  key   | 所有线程的key相同，若其他线程服务set相同的key时发现key已存在，则会等待锁 |
| values | 随机数，每个线程都不一样，用于持有锁的线程在删除缓存时判断是否为自己set的数据，是则不删除，否则不能删除 |
| expire | 过期时间，为了防止持有锁的线程服务宕机而不释放锁的情况，需要给key设置过期时间，即使出现宕机情况也仍然释放锁，保证其他线程的正常使用 |

##### 循环等待问题

​	等待锁时使用while(true)实现，影响性能。

​	解决方案：

1. 使用Redis的channel实现，当锁已被其他线程持有，且其他线程发起锁请求时，会向Redis发起订阅`SUBSCRIBE myLock`，当持有者释放锁时会通知其他线程锁已释放`PUBLISH myLock "I am release!"`，此时其他线程得到通知会去争夺锁。在业务层中，等待线程未收到消息时使用Java锁进行等待await，释放Java锁之后进入递归继续争抢。
2. Redisson

##### 锁失效问题

​	有可能缓存失效时间为30s，但是该线程本次执行用时为31s，会导致缓存提前失效，锁自动释放的情况，这时候其他线程拿到锁，可能影响到原持有锁线程的执行效果。

​	解决方案：心跳检测，在持有者执行到20s时续命，延长锁失效时间。业务层使用`Schedule`实现任务调度。

##### 原子操作问题

​	setnx和expire不是原子操作，get对比和del不是原子操作，可能会导致原子问题。

​	解决方案：lua脚本合成一条指令保证原子性。

#### Zookeeper (TODO)



